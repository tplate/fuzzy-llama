% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/sparsetsmat.R
\name{sparsetsmat}
\alias{sparsetsmat}
\alias{sparsetsmat.data.frame}
\alias{sparsetsmat.default}
\title{Sparse storage for persistent time-series data}
\usage{
sparsetsmat(x, ...)

\method{sparsetsmat}{data.frame}(x, date.col = 1, id.col = 2,
  value.col = 3, ids = attr(x, "ids"), sort.ids = non.null(attr(x,
  "sort.ids"), FALSE), backfill = non.null(attr(x, "backfill"), FALSE),
  keep.df.names = TRUE, drop.unneeded.dates = FALSE, POSIX = FALSE,
  tz = "UTC", ...)

\method{sparsetsmat}{default}(x, ids = attr(x, "ids"),
  sort.ids = non.null(attr(x, "sort.ids"), FALSE),
  backfill = non.null(attr(x, "backfill"), FALSE),
  drop.unneeded.dates = FALSE, drop.initial.NAs = FALSE, POSIX = FALSE,
  tz = "UTC", ...)
}
\arguments{
\item{x}{an object with data for a sparsetsmat: either a
data frame with three columns specifying the data
sparsely (dates, column lables and values), or a dense matrix.}

\item{...}{additional arguments for constructors}

\item{date.col}{The column of the data frame to get dates from (default = 1)}

\item{id.col}{The column of the data frame to get id from (default = 2)}

\item{value.col}{The column of the data frame to get values from (default = 3)}

\item{ids}{The complete set of ids to use.}

\item{sort.ids}{Should ids be sorted?  Affects how new data added to the object is treated. Default FALSE.}

\item{backfill}{Should a query with a data earlier than any for a particular id in the data get the value associated with the first date present in the data? Default FALSE.}

\item{keep.df.names}{Record the data frame column names so that when as.data.frame() is used on the sparsetsmat object, original names can be used?  Default TRUE.}

\item{drop.unneeded.dates}{Logical.  If TRUE, dates where
no value changes are completely forgotten.  If FALSE,
dates where no values change are still recorded in the
\code{all.dates} component of the object.  In both cases
dates where no value changes do not appear in the
\code{date} component of the returned object.  In both
cases, \code{all.dates} is a sorted version of the dates.}

\item{POSIX}{Should dates be POSIXct or Date? Default FALSE.}

\item{tz}{Time zone to use for dates, default is UTC.}

\item{drop.initial.NAs}{Logical.  For creating a
sparsetsmat object from a matrix: if \code{TRUE}, initial
NA's are ignored and not included in the explicit data.}
}
\value{
A \code{sparsetsmat} (S3) object with the following components:
\itemize{

  \item dates The dates of the underlying data.  Can be
\code{Date}, \code{POSIXct}, \code{double} or
\code{integer}.  This can have repititions of dates.

  \item values The values of the underlying data.  Can be
any atomic data type.  It is necessary to be able to do
operations like \code{matrix(x$values[1:6], ncol=2)} on
the values.  This vector must be the same length as
\code{date}.

  \item ids The id values.  May be sorted.

  \item id.idx The start value index into \code{date} and
\code{values} for each id.  Can contain NA values where an
id does not occur in the data.

  \item id.noc The number of occurences of each id in
\code{dates} and \code{values}.  Can contain zeros.

  \item all.dates class numeric, Date or POSIXct.
Records all the dates that have been stored in the data,
which can include dates on which no data changed, and
which will not be recorded in the \code{dates} component.
Will be sorted unless drop.unneeded.dates was FALSE and x
was a matrix with out-of-order dates as rownames.

  \item df.colnames colnames of the data.frame version

  \item backfill logical
}

The data are grouped by \code{ids} (possibly sorted) first
and sorted by \code{dates} second.  If there are no values
for a particular id the value in \code{id.idx} is
ignored.
}
\description{
Create a sparsetsmat object to store slow-changing
time-series data in a space-efficient manner.

sparsetsmat

sparsetsmat
}
\details{
A sparsetsmat object is an S3 object that stores
slow-changing data in a compact format.  See the Value
section for a description of the structure.
}
\examples{
m2.df <- data.frame(d=seq(as.Date('2001-01-01'), len=5, by='days')[
                        c(    1,  4,  5,  2,  1,  2,  3,  5)],
                      p=c('a','a','a','b','e','e','d','d'),
                      v=c(  1,  2,  3,  4,  5,  6,  7,  8))
m2.tsm <- sparsetsmat(m2.df, sort.ids=TRUE)
m2.tsm[, ]
m2.tsm
m2.mat <- as.matrix(m2.tsm)
attributes(m2.mat)
as.data.frame(m2.tsm)
as.matrix(m2.tsm)
# Ordinary square i,j indexing
m2.tsm[2,3]
m2.tsm[2,2:3]
m2.tsm[2,1:3]
m2.tsm[1:2,1:4]
# Matrix indexing
m2.tsm[cbind(c(2,3,4),c(1))]
m2.tsm[cbind(c(2,3,4),c(1,2,3))]
m2.tsm[cbind(c(2,3,4),c(3))]
# Matrix indexing using character indices
m2.tsm[data.frame(c('2001-01-01','2001-01-03','2001-01-05'),c('a','b','e'))]
}

