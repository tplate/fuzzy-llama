# make dimensions of x conform to y
# y can be a set of dimnames, or an object with dimnames

# if excess.ok==TRUE, dimension elements of x not in y are silently deleted
# if excess.ok==FALSE, an error is generated if x has dimension elements not in y

# If do.all=="union" or "intersect", all arguments are conformed to the
# union (or intersection) of all dimnames, and are returned in a list.
# With "union", this is the same behavior as when a list is supplied as the
# only argument.

# Rows or columns that must be introduced are filled with
# NA.  Note that introduced string values are "".

# x <- data.frame(row.names=letters[c(1,3,4,7,8)], i=1:5, d=(1:5)/10, f=as.factor(letters[22:26]), c=LETTERS[1:5], t=timeSeq(timeDate("2001/01/01"), len=5), stringsAsFactors=FALSE)

# x <- array(1:20,dim=c(5:4),dimnames=list(paste("R",1:5,sep=""),paste("C",1:4,sep="")))

conform <- function(x, ..., fill=NA, do.all=c("no", "union", "intersect"), along=NULL, excess.ok=TRUE, missing.ok=TRUE) UseMethod("conform")

# this method works with lists, or vectors, matrices and arrays
conform.default <- function(x, ..., fill=NA, do.all=c("no", "union", "intersect"), along=NULL, excess.ok=TRUE, missing.ok=TRUE) {
    do.all <- match.arg(do.all)
    nDotArgs <- length(match.call(expand.dots=FALSE)$...)
    if (is.list(x) && is.null(dim(x))) {
        # handle x being a list
        # excess.ok is irrelevant here -- no!
        if (nDotArgs==0) {
            if (do.all=="intersect")
                z.d <- do.call("intersect.dimnames", c(x, list(along=along)))
            else
                z.d <- do.call("union.dimnames", c(x, list(along=along)))
        } else if (nDotArgs==1) {
            if (is.dimnames(..1))
                z.d <- ..1
            else
                z.d <- dimnames(..1)
        } else {
            stop("can only have one ... arg when x is a list")
        }
        z <- list()
        for (i in seq(along=x))
            z[[i]] <- conform(x[[i]], z.d, fill=fill, do.all="no", along=along, excess.ok=excess.ok, missing.ok=missing.ok)
        if (!is.null(names(x)))
            names(z) <- names(x)
        return(z)
    } else {
        # handle x and ... being vectors, matrices and arrays
        if (do.all != "no") {
            return(conform.list(x=c(list(x), list(...)), fill=fill, do.all=do.all, along=along, excess.ok=excess.ok, missing.ok=missing.ok))
        } else if (is.list(x) && nDotArgs==0) {
            # can get incorrectly dispatched to conform.array when
            # x is a named list
            return(conform.list(x=x, fill=fill, do.all="union", along=along, excess.ok=excess.ok, missing.ok=missing.ok))
        }

        get.dimnames <- function(x) {
            if (is.dimnames(x))
                x
            else if (length(dim(x))) # instead of is.array(), which doesn't work for virtual arrays
                non.null(dimnames(x), rep(list(character(0)), length(dim(x))))
            else if (!is.null(names(x)))
                list(names(x))
            else
                list(character(0))
        }

        get.dim <- function(x) {
            if (length(dim(x)))
                dim(x)
            else
                length(x)
        }

        if (nDotArgs>1)
            if (do.all=='intersect')
                y.d <- intersect.dimnames(..., along=along)
            else
                y.d <- union.dimnames(..., along=along)
        else if (is.dimnames(..1))
            y.d <- ..1
        else
            y.d <- get.dimnames(..1)
        x.d <- get.dimnames(x)
        x.attr <- attributes(x)
        if (is.null(along)) {
            along <- seq(along=get.dim(x))
            if (length(x.d) != length(y.d))
                stop("x has ", length(x.d), " dimensions but y has ", length(y.d))
        } else {
            if (length(x.d) < max(along))
                stop("x has ", length(x.d), " dimensions max(along) is ", max(along))
            if (length(y.d) < max(along))
                stop("y has ", length(y.d), " dimensions max(along) is ", max(along))
        }

        if (!excess.ok)
            for (i in along)
                if (any(!is.element(x.d[[i]], y.d[[i]])))
                    stop("x has some dimname[", i, "] elements not in y, e.g.: ",
                         paste(some.examples(x.d[[i]][!is.element(x.d[[i]], y.d[[i]])]), collapse=", "))
        if (!missing.ok)
            for (i in along)
                if (any(!is.element(y.d[[i]], x.d[[i]])))
                    stop("x is missing some dimname[", i, "] elements that are in y, e.g.: ",
                         paste(some.examples(y.d[[i]][!is.element(y.d[[i]], x.d[[i]])]), collapse=", "))
        for (i in along) {
            if (!identical(x.d[[i]], y.d[[i]])) {
                # indexing with NA values generated by match for values of y.d not in x.d
                # will pull in correct NA rows
                args <- c(lapply(get.dim(x), function(n) seq(len=n)), list(drop=FALSE))
                args[[i]] <- match(y.d[[i]], x.d[[i]])
                x <- do.call("[", c(list(x), args))
                if (length(dim(x)))
                    dimnames(x)[[i]] <- y.d[[i]]
                else if (is.atomic(x) && i==1)
                    names(x) <- y.d[[i]]
                if (!is.na(fill)) {
                    rargs <- args[seq(len=length(x.d))]
                    rargs[[i]] <- which(is.na(rargs[[i]]))
                    if (length(rargs[[i]]))
                        x <- do.call("[<-", c(list(x), rargs, list(value=fill)))
                }
            }
        }
        # see if we need to put back any attributes of x that got lost
        # no, this doesn't work well -- better to just rely on behavior of [ and cbind
        if (FALSE) {
            for (a in intersect(names(attributes(x)), names(x.attr)))
                x.attr[[a]] <- NULL
            if (length(x.attr))
                attributes(x) <- c(attributes(x), x.attr)
        }
        return(x)
    }
}

# the *.list method doesn't get dispatched by S3, fold this into the default
conform.list <- function(x, ..., fill=NA, do.all=c("no", "union", "intersect"), along=NULL, excess.ok=TRUE, missing.ok=TRUE) {
    do.all <- match.arg(do.all)
    nDotArgs <- length(match.call(expand.dots=FALSE)$...)
    if (!is.list(x))
        stop("x must be a list")
    if (nDotArgs==0) {
        if (do.all=='intersect')
            z.d <- do.call("intersect.dimnames", c(x, list(along=along)))
        else
            z.d <- do.call("union.dimnames", c(x, list(along=along)))
    } else if (nDotArgs==1) {
        if (is.dimnames(..1))
            z.d <- ..1
        else
            z.d <- dimnames(..1)
    } else {
        stop("can only have one ... arg when x is a list")
    }
    z <- list()
    for (i in seq(along=x))
        z[[i]] <- conform(x[[i]], z.d, fill=fill, do.all="no", along=along, excess.ok=excess.ok, missing.ok=missing.ok)
    if (!is.null(names(x)))
        names(z) <- names(x)
    return(z)
}

conform.data.frame <- function(x, ..., fill=NA, do.all=c("no", "union", "intersect"), along=NULL, excess.ok=TRUE, missing.ok=TRUE) {
    do.all <- match.arg(do.all)
    nDotArgs <- length(match.call(expand.dots=FALSE)$...)
    if (do.all!="no")
        return(conform.list(x=c(list(x), list(...)), fill=fill, do.all=do.all, along=along, excess.ok=excess.ok, missing.ok=missing.ok))

    get.dimnames <- function(x) {
        if (is.dimnames(x))
            x
        else if (length(dim(x))) # instead of is.array(), which doesn't work for virtual arrays
            non.null(dimnames(x), rep(list(character(0)), length(dim(x))))
        else if (!is.null(names(x)))
            list(names(x))
        else
            list(character(0))
    }
    get.dim <- function(x) {
        if (length(dim(x)))
            dim(x)
        else
            length(x)
    }

    if (nDotArgs>1)
        if (do.all=='intersect')
            y.d <- intersect.dimnames(..., along=along)
        else
            y.d <- union.dimnames(..., along=along)
    else if (is.dimnames(..1))
        y.d <- ..1
    else
        y.d <- get.dimnames(..1)

    x.d <- get.dimnames(x)
    x.attr <- attributes(x)

    if (is.null(along)) {
        along <- seq(along=get.dim(x))
        if (length(x.d) != length(y.d))
            stop("x has ", length(x.d), " dimensions but y has ", length(y.d))
    } else {
        if (length(x.d) < max(along))
            stop("x has ", length(x.d), " dimensions max(along) is ", max(along))
        if (length(y.d) < max(along))
            stop("y has ", length(y.d), " dimensions max(along) is ", max(along))
    }
    if (!excess.ok)
        for (i in along)
            if (any(!is.element(x.d[[i]], y.d[[i]])))
                stop("x has some dimname[", i, "] elements not in y, e.g.: ",
                     paste(some.examples(x.d[[i]][!is.element(x.d[[i]], y.d[[i]])]), collapse=", "))
    if (!missing.ok)
        for (i in along)
            if (any(!is.element(y.d[[i]], x.d[[i]])))
                stop("x is missing some dimname[", i, "] elements that are in y, e.g.: ",
                     paste(some.examples(y.d[[i]][!is.element(y.d[[i]], x.d[[i]])]), collapse=", "))

    # fix rows
    if (is.element(1, along) && !identical(x.d[[1]], y.d[[1]])) {
        # indexing with NA values generated by match for values of y.d not in x.d
        # will pull in correct NA rows
        x <- x[i <- match(y.d[[1]], x.d[[1]]), , drop=FALSE]
        if (length(dim(x)))
            dimnames(x)[[1]] <- y.d[[1]]
        else
            names(x) <- y.d[[1]]
        if (!is.na(fill) && any(is.na(i)))
            x[which(is.na(i)), ] <- fill

    }
    # fix columns
    if (is.element(2, along) && !identical(x.d[[2]], y.d[[2]])) {
        if (length(dim(x))==0)
            stop("x is not a 2-d object")
        extra.i <- which(!is.element(y.d[[2]], x.d[[2]]))
        if (length(extra.i)) {
            if (length(dim(..1))) {
                # if we know the columns in y, use those types
                # need to use row indices of nrow(y)+1 to pull in correct number of rows
                # (indexing with 1 past end returns NA)
                extra.cols <- ..1[rep(length(y.d[[1]])+1, NROW(x)), extra.i, drop=FALSE]
                if (!is.na(fill) && nrow(x) > 0)
                    for (i in seq(len=ncol(extra.cols)))
                        extra.cols[seq(len=nrow(x)), i] <- fill
            } else {
                # Don't know column types from y (because all we have is dimnames)
                # If all columns in x have same class, use that class
                # Otherwise, fill with numeric NA columns
                if (!is.na(fill)) {
                    extra.cols <- matrix(fill, nrow=NROW(x), ncol=length(extra.i))
                } else if (is.data.frame(x) && length(unique(sapply(x, function(o) class(o)[1])))==1) {
                    extra.cols <- x[rep(length(x.d[[1]])+1, NROW(x)), rep(1, length(extra.i)), drop=FALSE]
                } else {
                    extra.cols <- matrix(as.double(NA), nrow=NROW(x), ncol=length(extra.i))
                }
            }
            dimnames(extra.cols) <- list(get.dimnames(x)[[1]], y.d[[2]][extra.i])
            # append the extra cols at the end of the data frame
            x <- cbind(x, extra.cols)
        }
        # get the columns in the right order
        x <- x[, match(y.d[[2]], get.dimnames(x)[[2]]), drop=FALSE]
    }

    # see if we need to put back any attributes of x that got lost
    for (a in intersect(names(attributes(x)), names(x.attr)))
        x.attr[[a]] <- NULL
    if (length(x.attr))
        attributes(x) <- c(attributes(x), x.attr)
    return(x)
}

# compute the union of dimnames
# union.dimnames(list(c("A","C"),c("b","c","d")), list(c("A","B"),c("a","c","d","e")))
# union.dimnames(list(c("A","C"),c("b","c","d")), list(c("A","B"),c("a","c","d","e")), list(c("A","D"),c("f")))


union.dimnames <- function(..., along=NULL) {
    get.dimnames <- function(x) {
        if (is.dimnames(x))
            x
        else if (length(dim(x))) # instead of is.array(), which doesn't work for virtual arrays
            non.null(dimnames(x), rep(list(character(0)), length(dim(x))))
        else if (!is.null(names(x)))
            list(names(x))
        else
            NULL
    }
    nDotArgs <- nargs() - !missing(along)
    # make x be the first object with dimnames, and args be a list of the remainder
    if (is.list(..1) && !is.data.frame(..1) && !is.dimnames(..1) && !is.virtual.array(..1)) {
        x <- get.dimnames(..1[[1]])
        args <- c(..1[-1], list(...)[-1])
        args.names <- paste("obj", seq(along=args), sep="")
    } else {
        x <- get.dimnames(..1)
        args <- list(...)[-1]
        if (length(args)) {
            args.names <- names(args)
            if (is.null(args.names) || any(args.names == ""))
                args.names <- mapply(non.null(args.names, character(length(args))),
                                     match.call(expand.dots=FALSE)$...[-1],
                                     FUN=function(x, y) if (x!="") return(x) else return(deparse(y)))
        }
    }
    if (!is.dimnames(x))
        stop("first argument is not a dimnames object and has no dimnames")
    for (i in seq(along=args)) {
        y <- get.dimnames(args[[i]])
        if (!is.dimnames(y))
            stop(args.names[i], "is not a dimnames object and has no dimnames")
        if (is.null(along)) {
            if (length(x) != length(y))
                stop(args.names[i], " has ", length(y), " dimensions but ", args.names[1], " has ", length(x))
            for (j in seq(along=x)) {
                dd <- union.ordered(x[[j]], y[[j]])
                if (!is.null(dd))
                    x[[j]] <- dd
            }
        } else {
            if (length(x) < max(along) || length(y) < max(along))
                stop(args.names[i], " has ", length(y), " dimensions and x has ", length(x), " but along=", paste(along, collaspe=", "))
            for (j in along) {
                dd <- union.ordered(x[[j]], y[[j]])
                if (!is.null(dd))
                    x[[j]] <- dd
            }
        }
    }
    x
}

# compute the intersect of dimnames
# intersect.dimnames(list(c("A","C"),c("b","c","d")), list(c("A","B"),c("a","c","d","e")))
# intersect.dimnames(list(c("A","C"),c("b","c","d")), list(c("A","B"),c("a","c","d","e")), list(c("A","D"),c("f")))


intersect.dimnames <- function(..., along=NULL) {
    get.dimnames <- function(x) {
        if (is.dimnames(x))
            x
        else if (length(dim(x))) # instead of is.array(), which doesn't work for virtual arrays
            non.null(dimnames(x), rep(list(character(0)), length(dim(x))))
        else if (!is.null(names(x)))
            list(names(x))
        else
            NULL
    }
    nDotArgs <- nargs() - !missing(along)
    # make x be the first object with dimnames, and args be a list of the remainder
    if (is.list(..1) && !is.data.frame(..1) && !is.dimnames(..1) && !is.virtual.array(..1)) {
        x <- get.dimnames(..1[[1]])
        args <- c(..1[-1], list(...)[-1])
        args.names <- paste("obj", seq(along=args), sep="")
    } else {
        x <- get.dimnames(..1)
        args <- list(...)[-1]
        if (length(args)) {
            args.names <- names(args)
            if (is.null(args.names) || any(args.names == ""))
                args.names <- mapply(non.null(args.names, character(length(args))),
                                     match.call(expand.dots=FALSE)$...[-1],
                                     FUN=function(x, y) if (x!="") return(x) else return(deparse(y)))
        }
    }
    if (!is.dimnames(x))
        stop("first argument is not a dimnames object and has no dimnames")
    for (i in seq(along=args)) {
        y <- get.dimnames(args[[i]])
        if (!is.dimnames(y))
            stop(args.names[i], "is not a dimnames object and has no dimnames")
        if (is.null(along)) {
            if (length(x) != length(y))
                stop(args.names[i], " has ", length(y), " dimensions but x has ", length(x))
            for (i in seq(along=x))
                x[[i]] <- intersect(x[[i]], y[[i]])
        } else {
            if (length(x) < max(along) || length(y) < max(along))
                stop(args.names[i], " has ", length(y), " dimensions and x has ", length(x), " but along=", paste(along, collaspe=", "))
            for (i in along)
                x[[i]] <- intersect(x[[i]], y[[i]])
        }
    }
    x
}

# Compute the union, and keep the symbols in the same order as in x and y
# (provided that x and y are consistently ordered).

# Differs from union() in elements of y that are not in x can
# still appear before elements of x in the output.

# union.ordered(c("a","b","d","g"),c("a","c","e","g"))
# union.ordered(c("c","b"), c("a","c","d"))

union.ordered <- function(x, y) {
    if (is.null(x)) return(y)
    else if (is.null(y)) return(x)
    out.of.order <- any(x[-1] < x[-length(x)]) || any(y[-1] < y[-length(y)])
    if (!isTRUE(out.of.order)) {
        return(sort(union(x, y), na.last=TRUE))
    } else {
        # check if x and y are ordered consistently
        z <- intersect(x, y)
        z <- z[!is.na(z)]
        consistently.ordered <- all(diff(match(z, y))>=0) && all(diff(match(z, x))>=0)
        w <- union(x, y)
        if (!consistently.ordered)
            return(w)
        if (any(dup <- duplicated(x)))
            x <- x[!dup]
        if (any(dup <- duplicated(y)))
            y <- y[!dup]
        x.both <- is.element(x, z)
        y.both <- is.element(y, z)
        i <- 1 # count along x
        j <- 1 # count along y
        k <- 1 # count along w
        # transfer elts from x and y to w
        while (k <= length(w)) {
            while (!x.both[i] && i<=length(x)) {
                w[k] <- x[i]
                k <- k+1
                i <- i+1
            }
            while (!y.both[j] && j<=length(y)) {
                w[k] <- y[j]
                k <- k+1
                j <- j+1
            }
            if (i<=length(x)) {
                w[k] <- x[i]
                k <- k+1
                i <- i+1
                j <- j+1
            }
        }
        return(w)
    }
}

is.dimnames <- function(x) {
    return(is.list(x) && all(is.element(set=c("NULL", "character"), sapply(x, class))) && all(sapply(x, function(x) is.null(names(x)))))
}

non.null <- function(x, y) if (is.null(x)) y else x

# pick some initial elements from a vector
some.examples <- function(x, max.examples=3, collapse=NULL,
                          quote=FALSE, ellipsis=FALSE, total=FALSE, final=FALSE)
{
    len <- length(x)
    # don't return something like 'A, B, ..., D' for 'A, B, C, D'
    if (len == max.examples+1 && ellipsis)
        max.examples <- len
    xc <- as.character(x)
    if (final)
        xc <- xc[unique(c(seq(len=min(len, max.examples-1)), len))]
    else
        xc <- xc[seq(len=min(len, max.examples))]
    if (is.logical(quote) && quote)
        quote <- "\""
    if (is.logical(collapse))
        if (collapse)
            collapse <- ", "
        else
            collapse <- NULL
    if (is.character(quote))
        xc <- paste(quote, xc, quote, sep="")
    if (ellipsis && len > max.examples)
        if (final)
            xc <- c(head(xc, -1), "...", tail(xc, 1))
        else
            xc <- c(xc, "...")
    if (!is.null(collapse))
        xc <- paste(xc, collapse=collapse)
    if (total && len > max.examples)
        if (!is.null(collapse))
            xc <- paste(xc, " (", len, " total)", sep="")
        else
            xc <- c(xc, paste("(", len, " total)", sep=""))
    xc
}
